package net.sf.JRecord.cg.details;

import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

import net.sf.JRecord.Common.Conversion;
import net.sf.JRecord.cg.details.codes.ArgumentOption;
import net.sf.JRecord.cg.details.codes.CobolDialects;
import net.sf.JRecord.cg.details.codes.CopybookSplit;
import net.sf.JRecord.cg.details.codes.FileOrganisation;
import net.sf.JRecord.cg.schema.LayoutDef;
import net.sf.JRecord.cg.schema.RecordDef;

public class WriteCodeGenCall {
	
	static {
		CobolDialects.init();
		CopybookSplit.init();
		FileOrganisation.init();
	}
	
	private final IGenerateOptions genOptions;
	private final String cobolCopybook;
	
	private String deciderName, deciderCreationCode;
	
	public WriteCodeGenCall(IGenerateOptions genOptions,  String cobolCopybook) {
		this.genOptions = genOptions;
		this.cobolCopybook = cobolCopybook;
	}

	/**
	 * @param deciderName the deciderName to set
	 */
	public void setDeciderDetails(String deciderName, String deciderCreationCode) {
		this.deciderName = deciderName;
		this.deciderCreationCode = deciderCreationCode;
	}
//
//	public void writeCode(String filename, String cobolCopybook) throws IOException {
//		writeCode(new FileWriter(filename));
//	}
//
//	public void writeCode(Writer out) throws IOException {
//		appendCode(out);
//		out.close();
//	}
//	
//	public void writeCode(Appendable out) throws IOException {
//		appendCode(out);
//	}
	
	public void writeTemplateBuilderCode() throws IOException {
		String className = "Generate" + genOptions.getSchemaDefinition().getExtensionName();
		writeTemplateBuilderCode("codeGen", className);
	}

	public void writeTemplateBuilderCode(String packageId) throws IOException {
		String className = "Generate" + genOptions.getSchemaDefinition().getExtensionName();
		writeTemplateBuilderCode(packageId, className);
	}

	public void writeTemplateBuilderCode(
			String packageId,
			String className) throws IOException {
		TemplateDtls templateDtls = genOptions.getTemplateDtls();
		if (templateDtls == null) {
			throw new RuntimeException("You must set the template details before making this call");
		}
		FileWriter writer = new FileWriter(genOptions.getOutputDir() + "/" + className + ".java");
		writeTemplateBuilderCodeInternal(
				writer, 
				packageId, className, 
				templateDtls.getTemplateNameDtls());
		writer.close();
	}
	
	public void writeTemplateBuilderCode(
			Writer writer,
			String packageId,
			String className,
			TemplateName templateName) throws IOException {
		
		this.writeTemplateBuilderCodeInternal(writer, packageId, className, templateName);
		writer.close();
	}
	
	public void writeTemplateBuilderCode(
			Appendable writer,
			String packageId,
			String className,
			TemplateName templateName) throws IOException {
		this.writeTemplateBuilderCodeInternal(writer, packageId, className, templateName);
	}
	
	public void writeTemplateBuilderCodeInternal(
			Appendable writer,
			String packageId,
			String className,
			TemplateName templateName) throws IOException {
		LayoutDef schemaDef = genOptions.getSchemaDefinition();
		//LayoutDetail layout = genOptions.getLayout();
		
		
		writer.append("" +
				"package " + packageId + ";\n" + 
				"\n" + 
				"import java.io.IOException;\n" + 
				"\n" + 
				"import javax.xml.stream.FactoryConfigurationError;\n" + 
				"import javax.xml.stream.XMLStreamException;\n" + 
				"\n" + 
				"import net.sf.JRecord.JRecordInterface1;\n" + 
				"import net.sf.JRecord.cg.CodeGenInterface;\n" + 
				"import net.sf.JRecord.cg.details.codes.CobolDialects;\n" + 
				"import net.sf.JRecord.cg.details.codes.CopybookSplit;\n" +
				"import net.sf.JRecord.cg.details.codes.FileOrganisation;\n" + 
				"import net.sf.JRecord.cg.details.codes.StandardTemplates;\n" + 
				"import net.sf.JRecord.def.IO.builders.recordDeciders.ISingleFieldDecider;\n" + 
				"\n" +
				" /**\n" + 
				"   *  Purpose: Run JRecord-CodeGen to generate java code\n" + 
				"   *           to read write files for Cobol Copybook: " + schemaDef.getCobolName()
					+ "    \n" + 
				"   *\n" + 
				"   *  This code is generated by CodeGen. There are three main reasons to   \n" + 
				"   *  generate this class:\n" + 
				"   *  1) When generating code from the RecordEditor/ReCsvEditor, it allows\n" + 
				"   *     the interface to be regenerated using Just the CodeGen package\n" + 
				"   *  2) Using batch interface (bat / shell script) this class will be\n" + 
				"   *     generated the new Java interface in the future.\n" + 
				"   *  3) When using the File analysis option to derive attributes, this\n" + 
				"   *     generated class will hard code the attributes for future use with out \n" + 
				"   *     the file.\n" + 
				"   */\n" + 
				"public class " + className +" {\n\n" + 
				"	public static void main(String[] args) throws IOException, XMLStreamException, FactoryConfigurationError {\n\n");
//		String deciderName = null;
//		if (decider instanceof ISingleFieldDeciderDetails) {
//			writer.write("\t\tISingleFieldDecider deciderDescription = " + schemaDef.createDeciderClass() + ";\n\n");
//			deciderName = "deciderDescription";
//		}
		
		if (deciderName !=null && deciderCreationCode != null) {
			writer.append(deciderCreationCode + "\n");
		}

		writer.append("\t\tCodeGenInterface.TEMPLATES.newTempateBuilder(\"" + fixForInQuotes(cobolCopybook) + "\")\n");
		
//		if (dialect !=) {
		printVal(writer, "setCobolDialect", genOptions.getDialect());
//		for (CobolDialects c : CobolDialects.values()) {
//			if (c.option == dialect) {
//				printVal(writer, "setCobolDialect", c);
//			}
//		}
		printVal(writer, "setFileOrganisation", genOptions.getFileStructureCode());
		
		printVal(writer, "setCopybookSplitOption", genOptions.getSplitOption());
		writer.append("\t\t\t.setFont(\"" + genOptions.getFont() + "\")\n");
		
		if (deciderName != null) {
			writer.append("\t\t\t.addRecordDecider(" + deciderName + ")\n");
		} else if (schemaDef.getRecords().size() > 1) {
			for (RecordDef r : schemaDef.getRecords()) {
				String recordSelectionStr = r.getRecordSelectionStr();
				if (recordSelectionStr == null || recordSelectionStr.length() == 0) {
					writer.append("\t\t\t//TODO .addRecordSelection(\"" + r.getCobolName() + "\", )\n");
				} else {
					writer.append("\t\t\t.addRecordSelection(\"" + r.getCobolName() + "\",\n"
							+ "\t\t\t\t" + recordSelectionStr + ")\n");
				}
			}
		}
		
		if (templateName.template == null) {
			writer.append("\t\t\t.setUserTemplate(\"" + templateName.userTemplate + "\")\n");
		} else {
			printVal(writer, "setTemplate", templateName.template);
		}
		writer.append("" +
				"\t\t\t.setPackageName(\"" + genOptions.getPackageId() +"\")\n" + 
				"\t\t\t.setOutputDirectory(\"" + fixForInQuotes(genOptions.getOutputDir()) +"\")\n" + 
				"\t\t\t.generateJava();\n" + 
				"" +
				"\t}\n" + 
				"}");
	}
	
	private String fixForInQuotes(String v) {
		StringBuilder b = Conversion.replace(v, "\\", "\\\\");
		return b.toString();
	}

	
	private void printVal(Appendable writer, String methodName, Enum<?> enumValue) throws IOException {
		writer.append("\t\t\t." + methodName + "(" + enumValue.getClass().getSimpleName() + "." + enumValue.name() + ")\n");
	}
	
	private void printVal(Appendable writer, String methodName, ArgumentOption opt) throws IOException {
//		if (opt.codeGenCodePresent()) {
		writer.append("\t\t\t." + methodName + "(" + opt.getCodeGenCode() + ")\n");
//		} else {
//			
//		}
	}


}
